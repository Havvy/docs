<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.11.4">
    <title>Scoping Rules – Elixir v1.3.0-dev</title>
    <link rel="stylesheet" href="dist/app-ddd9717ad9.css" />
    <script src="dist/sidebar_items.js"></script>
  </head>
  <body data-type="extras">

<div class="main">
<button class="sidebar-toggle">
  <i class="icon-menu"></i>
</button>
<section class="sidebar">
  <button class="sidebar-toggle">
    <i class="icon-menu"></i>
  </button>

  
  <a href="http://elixir-lang.org/docs.html" class="sidebar-projectLink">
    <div class="sidebar-projectDetails">
      <h1 class="sidebar-projectName">
        Elixir
      </h1>
      <h2 class="sidebar-projectVersion">
        v1.3.0-dev
      </h2>
    </div>
    
      <img src="assets/logo.png" alt="Elixir" class="sidebar-projectImage">
    
  </a>

  <div class="sidebar-search">
    <i class="icon-search"></i>
    <input type="text" class="sidebar-searchInput" placeholder="search" autocomplete="off" />
  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>

    
      <li><a id="modules-list" href="#full-list">Modules</a></li>
    

    
      <li><a id="exceptions-list" href="#full-list">Exceptions</a></li>
    

    
      <li><a id="protocols-list" href="#full-list">Protocols</a></li>
    
  </ul>

  <ul id="full-list" class="sidebar-fullList"></ul>
  <div class="sidebar-noResults"></div>
</section>

<section class="content">
  <div id="content" class="content-inner">


<h1>Scoping Rules</h1>
<p>This document will describe Elixir scoping rules both for variables and its lexical directives.</p>
<h2 id="variable-scoping"> Variable scoping</h2><p>Elixir constructs can be split in three categories:</p>
<ul>
<li>The ones that do not introduce a new scope (like <code class="inline">if</code>/<code class="inline">case</code>/<code class="inline">cond</code>/<code class="inline">receive</code>)
</li>
<li>The ones that introduce a new scope (like <code class="inline">fn</code>/<code class="inline">try</code>/<code class="inline">for</code>/<code class="inline">with</code>)
</li>
<li>The ones that introduce an empty new scope (like <code class="inline">def</code>/<code class="inline">defp</code>/<code class="inline">defmacro</code>)
</li>
</ul>
<p>For instance, <code class="inline">if</code> does not introduce a new scope. Therefore rebinding a variable inside <code class="inline">if</code> “inner” scope will affect its “outer” scope:</p>
<pre><code class="elixir">x = 0
if true do
  x = 1
end
x #=&gt; 1</code></pre>
<p>Since “if” does not introduce a new scope, there is no “inner” and “outer” in this case. It has been the same scope all along.</p>
<p>Constructs like <code class="inline">fn</code> introduce a new scope, on top of the current one. Defining a variable inside <code class="inline">fn</code> won’t affect its outer scope:</p>
<pre><code class="elixir">x = 0
(fn -&gt; x = 1 end).()
x #=&gt; 0</code></pre>
<p>Besides the basic constructs like <code class="inline">fn</code>, <code class="inline">for</code> and <code class="inline">try</code>, any other construct built on top of those will keep those properties. For example, <code class="inline">defmodule</code> is implemented on top of <code class="inline">fn</code>:</p>
<pre><code class="elixir">x = 0
defmodule Foo do
  x = 1
end
x #=&gt; 0</code></pre>
<p>Finally, there are constructs that introduce a new <em>empty</em> scope. Such as <code class="inline">def</code> and friends that are used to define functions in modules:</p>
<pre><code class="elixir">defmodule Bar do
  x = 0
  def bar do
    x #=&gt; is not defined here
  end
end</code></pre>
<p>Those are the three categories regarding variables scopes in Elixir. Any other construct will be built on top of those basic rules and consequently belong to one of those three categories.</p>
<h2 id="lexical-scoping"> Lexical scoping</h2><p>Elixir’s <code class="inline">import</code>, <code class="inline">alias</code> and <code class="inline">require</code> follow lexical scoping rules. This means it is possible to determine the scope of those constructs only by looking at the source code.</p>
<p>When you <code class="inline">alias</code> a module, it will affect all upcoming code in the same code branch:</p>
<pre><code class="elixir"># U is not available here
alias URI, as: U
# U is available here</code></pre>
<p>If you alias at the top of a file, the alias will be available inside of any module, as well as any function or construct in that file:</p>
<pre><code class="elixir">alias URI, as: U        T -----------------+
                                           |
defmodule M do            M -------------+ | 
  @moduledoc &quot;M module&quot;                  | | 
                                         | | 
  def abs(n) do             F ---------+ | | # T: top level / file scope
    cond do                   C -----+ | | | # M: module&#39;s scope
      n &lt; 0  -&gt; -n                   | | | | # F: function clause scope
      n &gt;= 0 -&gt; n                    | | | | # C: cond&#39;s scope
      _                              | | | |
    end                         -----+ | | | 
  end                         ---------+ | | 
end                         -------------+ | 
                          -----------------+</code></pre>
<p>On the other hand, importing, aliasing or requiring a module in a nested scope won’t affect the outer one. For example, aliasing inside the module scope won’t affect the file scope:</p>
<pre><code class="elixir"># U is NOT available here

defmodule M do
  alias URI, as: U
  # U is available here

  def my_fun do
    # U is available here
  end
end

# U is NOT available here</code></pre>
<p>Similarly, applying any of those directives inside a function will be available to the expressions inside that particular function:</p>
<pre><code class="elixir">defmodule M do
  def my_fun do
    alias URI, as: U
    # U is available here
  end

  def other_fun do
    # U is NOT available here
  end
end</code></pre>
<p>The same is true for constructs with multiple clauses like <code class="inline">case</code>, <code class="inline">cond</code> and <code class="inline">fn</code>. The directive will only affect the clause it is in: </p>
<pre><code class="elixir"># U is NOT available here

cond do
  n &lt; 0 -&gt;
    alias URI, as: U
    # U is available here
  n &gt;= 0 -&gt;
    # U is NOT available here
end

# U is NOT available here</code></pre>
<p>All of those rules are tied to Elixir syntax. <code class="inline">do</code>/<code class="inline">end</code> blocks define precisely where each scope starts and ends. Constructs with multiple clauses are properly indented on each clause, making it straight-forward for Elixir developers to understand at a glance the effect of Elixir directives.</p>

    <footer class="footer">
      <p>
        <span class="line">
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" rel="help" target="_blank">ExDoc</a> (v0.11.4),
        </span>
        <span class="line">
          designed by
          <a href="https://twitter.com/dignifiedquire" target="_blank" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
      </p>
      <button class="night-mode-toggle" />
    </footer>
  </div>
</section>
</div>
  <script src="dist/app-6d2e071366.js"></script>
  </body>
</html>

